from langchain_openai import ChatOpenAI 
from langchain.agents import create_react_agent,  AgentExecutor,tool
from langchain_core.prompts import PromptTemplate
from langchain.memory import ConversationBufferMemory,ConversationSummaryMemory 
from openai import OpenAI
import os
import pandas as pd
import json
import ast
import subprocess
import re
# 从环境变量中获取 API key
llm_model = ChatOpenAI(
    model="gpt-4o-2024-08-06",
    temperature=0.2,
    max_tokens=1000,
    api_key=os.getenv("OPENAI_API_KEY"),
    base_url="https://api.chatanywhere.tech/v1"
)
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"),base_url="https://api.chatanywhere.tech/v1")
template = '''
            Answer the following questions by Chinese as best you can. You have access to the following tools:
            Please note that when calling the tool during this process, the Action Input can only be a string or a list; other data structures cannot be used. For example, you can only select `'datasets/1/merged.csv'` or `'datasets/1/testcase.txt'`.
            If you find that the QTA generated by the tools is incorrect, you cannot modify it yourself and need to rely on the tools to regenerate it.

            When using this tools, remember to validate outputs from tools provided by other large language models (LLMs), as they may contain inaccuracies.
            {tools}

            the most important things!!!!!!
            Please strictly follow the format below, which takes the highest priority:Use the following format:


            Thought: you should always think about what to do
            Action: the action to take, should be one of [{tool_names}]
            Action Input: the input to the action.
            Observation: the result of the action
            ... (this Thought/Action/Action Input/Observation can repeat 3 times)

            Thought: I now know the final answer
            Final Answer: the final answer to the original input question, verified by the QTA result.
           
            Begin!
            Remember, you do not always need to use tools. Do not provide information the user did not ask for.
            
            Question: {input}
            Thought:{agent_scratchpad}'''


#*****************************************************************************************************************************************************************#

def chat(content=""):
        """
        GPT接口
        :param content: 输入的问题内容，若为空则函数直接返回
        :return: 以 JSON 格式返回服务器的响应
        """
        try:
            chat_response = client.chat.completions.create(
                model="gpt-4o-2024-08-06",  # 确保使用正确的模型
                messages=[{"role": "system", "content": "You are an assistant."},
                          {"role": "user", "content": content}]
            )

            # 确保响应和choices存在且非空
            if chat_response and chat_response.choices:
                return chat_response.choices[0].message.content
            else:
                raise ValueError("Received an empty response from the API.")

        except Exception as e:
            print(f"Error during chat completion: {e}")
            return None
        
def extract_llm_test(text_content):
    # 使用正则表达式匹配代码块
    #print(type(text_content))
    code_pattern = re.compile(r'```python(.*?)```', re.DOTALL)
    code_blocks = code_pattern.findall(text_content)
    # 提取第一个匹配的代码块作为示例
    if code_blocks:
        code_content = code_blocks[0]
    else:
        code_content = "没有找到代码块"
    return code_content

def parse_json(json_str, key_list):
    """
    递归解析
    :param json_str: 一个包含JSON数据的字符串
    :param key_list: 一个包含要提取的键的列表
    :return: 在 json_str 中找到的第一个匹配 key_list 中键的值
    """
    try:
        data = json.loads(json_str.replace("'", "\""))
    except json.JSONDecodeError:
        data = ast.literal_eval(json_str)

    def extract(data, keys):
        if isinstance(data, dict):
            for key, value in data.items():
                if key in keys:
                    return value
                result = extract(value, keys)
                if result is not None:
                    return result
        elif isinstance(data, list):
            for item in data:
                result = extract(item, keys)
                if result is not None:
                    return result

    return extract(data, key_list)  
  
def find_and_extract_fields(api_des_path,cleaned_path, possible_fields):
    """
    解析出所有关联参数并存在
    :param df: 一个 pandas DataFrame对象
    :param possible_fields: 一个列表，包含可能存在于DataFrame的JSON字符串中要提取的字段名
    :param return :解析出所有字段的df对象
    """
    api_des = pd.read_csv(api_des_path)#第一个参数是接口集路径，第二个参数是原始日志路径
    cleaned = pd.read_csv(cleaned_path)
    unique_URLs = api_des['URL'].drop_duplicates().tolist()
    df= cleaned[cleaned['URL'].isin(unique_URLs)]
    for field in possible_fields:
        # 从 'Request' 列中提取字段
        df[field] = df['Request'].apply(lambda x: parse_json(x, [field]))
        
        # 如果 'Request' 中没有找到，则从 'Response' 列中提取字段
        df[field] = df.apply(
            lambda row: parse_json(row['Response'], [field]) if row[field] is None else row[field],
            axis=1
        )
    
    return df

def sort_and_select_logs(df,api_des_path):
    """
    :param df: 一个 pandas DataFrame对象
    :param api_des_path: 包含API描述的CSV文件的路径，这些描述中包括了需要覆盖的URL列表
    :return: 一个被选中的日志条目列表，这些日志条目覆盖了API描述中的所有URL。如果在处理完所有分组之前就已经达到了覆盖所有URL的目标，函数将提前返回选中的日志。
    """

    all_groups = []
    seen_groups = set()
    ungrouped_logs = []  # 新增一个列表来存储未分组的日志
    processed_indices = set()  # 这里将处理过的索引集初始化放在循环外
    excluded_columns=['URL', 'Request', 'Response', 'Method']
    columns_to_categorize = [col for col in df.columns if col not in excluded_columns]
    # 确保不会因解析参数为list而报错
    for col in columns_to_categorize:
        if col not in excluded_columns:
            df[col] = df[col].apply(
                lambda x: ', '.join(map(str, x)).strip('[]') if isinstance(x, list) else x
            )
    for col in columns_to_categorize:
        grouped = df.groupby(col)
        for value, group in grouped:
            if pd.notna(value):
                unprocessed_group = group[~group.index.isin(processed_indices)]
                if not unprocessed_group.empty:
                    current_group = [dict(URL=row['URL'], Request=row['Request'], Response=row['Response']) for
                                        _, row
                                        in unprocessed_group.iterrows()]
                    group_hash = frozenset(tuple(d.items()) for d in current_group)
                    if group_hash not in seen_groups:
                        all_groups.append(current_group)
                        seen_groups.add(group_hash)
                    processed_indices.update(unprocessed_group.index)

    # 处理未被分组的日志
    ungrouped_indices = set(df.index) - processed_indices
    for idx in ungrouped_indices:
        row = df.loc[idx]
        ungrouped_logs.append(dict(URL=row['URL'], Request=row['Request'], Response=row['Response']))

    # 如果有未分组的日志，将它们作为一个单独的分组添加到结果中
    if ungrouped_logs:
        all_groups.append(ungrouped_logs)

    grouped_logs=all_groups


    api_des = pd.read_csv(api_des_path)
    api_URLs = set(api_des['URL'].tolist())
    grouped_logs.sort(key=len, reverse=True)
    selected_logs = []
    covered_URLs = set()
    for group in grouped_logs:
        group_URLs = set([log['URL'] for log in group])
        if not group_URLs.issubset(covered_URLs):
            selected_logs.extend(group)
            covered_URLs.update(group_URLs)
            if covered_URLs >= api_URLs:
                break
    return selected_logs
def run_QTA_and_return_result(input_test_file: str) -> str:
    """
    ## 工具描述:执行指定的 QTA 测试用例文件，并返回测试结果。
    ##示例输入格式："/path/to/test_n.py"
    :param input_test_file: QTA接口测试用例文件的路径。
    :return: 测试结果的输出内容
    """
    input_test_file=input_test_file.strip('"').strip("'").strip().replace('"', '').replace("'", '').replace("/", ".")
    match = re.search(r'\.([^.]+)\.([^.]+)\.py$', input_test_file)

    input_test_file = f"{match.group(1)}.{match.group(2)}"

    # 运行 QTA 并获取输出结果
    command = 'python '+'medtesttestproj/manage.py '+'runtest '+input_test_file
    try:
        # 通过 subprocess 运行命令并捕获输出，指定编码为 utf-8
        result = subprocess.run(command, capture_output=True, text=True, check=True, shell=True, encoding='utf-8', errors='replace')

        # 将标准输出和标准错误保存为字符串
        output = result.stdout  # 标准输出
        #error_output = result.stderr  # 标准错误
        #print(output)
        return output  # 返回输出和错误输出作为字符串
    except subprocess.CalledProcessError as e:
        # 如果命令失败，捕获并返回错误信息
        return e.stdout  # 返回捕获到的输出和错误信息

def get_url_and_steps(csv_path):
    # 读取 CSV 文件
    try:
        df = pd.read_csv(csv_path)
    except FileNotFoundError:
        return f"文件 {csv_path} 未找到。"
    except Exception as e:
        return f"读取文件时发生错误: {e}"

    # 检查是否存在需要的列
    if 'URL' not in df.columns or '用例步骤' not in df.columns:
        return "CSV 文件中缺少 'URL' 或 '用例步骤' 列。"

    # 按照一一对应的方式将 URL 和用例步骤保存为字符串
    result = ""
    for url, step in zip(df['URL'], df['用例步骤']):
        result += f"URL: {url}, 用例步骤: {step}\n"
    
    return result

def AddLogStatements(input_string: str) -> str:
    """
    ## 工具描述: 该工具用于在 QTA 测试用例代码中加入打印日志的语句，以便后续步骤进行调试。
    ## 输入变量说明：
    传入变量为`input_string`，包含以下内容，使用空格分隔：
    1. QTA 测试用例代码保存路径(文件类型为.py)（`qta_code_path`）。

    示例输入格式："/path/to/qta_code.py"
    """

    qta_code_path = input_string

    #print(qta_code_path)
    # 读取 QTA 测试用例代码
    if not os.path.exists(qta_code_path):
        return f"无法找到 QTA 测试用例路径 {qta_code_path}"

    with open(qta_code_path, 'r', encoding='utf-8') as file:
        qta_code_content = file.read()
    #print( qta_code_content)
    # 创建 LLM 提示以插入日志打印语句
    prompt = f"""
    ### 在 QTA 测试用例代码中加入日志打印语句

    以下是 QTA 测试用例代码，请在适当的位置加入日志打印语句，以便后续步骤进行调试。

    #### QTA 测试用例代码:
    {qta_code_content}

    ### 请在每个接口调用之后加入类似如下的日志打印语句：
    self.log_info(f"Response Body: {{response.text[:1000]}}")

    确保日志打印语句符合代码的逻辑并且位置正确。
    """
    #print(prompt)
    # 使用 LLM 生成插入日志后的代码
    response = chat(prompt)
    QTA_code=extract_llm_test(response)
    # 保存更新后的代码
    with open(qta_code_path, 'w', encoding='utf-8') as file:
        file.write(QTA_code)

    return f"已在 QTA 测试用例中加入日志打印语句，更新后的代码已保存到: {qta_code_path} 中。"
#*****************************************************************************************************************************************************************#


@tool
def FindPossibleFieldsByLLM(input_string:str) -> str:
    """
    ##工具描述：通过接口定义和回包信息，以及文本用例判断可能存在依赖的字段，并返回字符串类型的字段列表。
    ##若通过此工具返回空列表找不到依赖的字段可能是由于LLM出错导致，请重试几次！！
    ##请注意！！1.传入变量为input_string,其中包含接口集路径文本用例存放路径，中间只能用空格隔开，输入格式示例："datasets/1/merged.csv datasets/1/testcase.txt"。
               2.该工具由LLM提供服务，如果找不到依赖的字段或者返回中文字段可能是因为LLM出错导致。
               
    :param merge_path: 接口集路径
    :param testcase_path: 文本用例存放路径
    :return: 返回可能字段列表
    """
    merge_path, testcase_path = input_string.split()

    merge_path = merge_path.strip('"').strip("'").replace('"', '').replace("'", '')
    testcase_path = testcase_path.strip('"').strip("'").replace('"', '').replace("'", '')
    try:
        # 读取CSV文件，检查文件是否存在或格式是否正确
        data = pd.read_csv(merge_path)
        
        # 拼接接口定义及回包信息
        combined_info = data.apply(lambda x: f"URL: {x['URL']}, 回包信息: {x['回包信息']}", axis=1).tolist()
    
        # 读取文本用例文件
        with open(testcase_path, 'r', encoding='utf-8') as file:
            text = file.read()

        # 构建生成测试用例的提示
        prompt = f"""
        根据以下文本用例、接口定义及回包信息，确定在执行该用例时，日志中哪些字段存在上下游依赖（即参数在上下游接口之间流转），并在多个接口的请求（request）和响应（response）中重复出现。

        ##规则：
        1. 返回依赖字段的列表，格式为：['Field1', 'Field2']。确保字段名是英文且与接口定义严格一致。
        2. 如果不存在依赖字段，返回空列表，格式为：[]。

        ##文本用例：
        {text}

        ##详细信息：
        {combined_info}

        ##注意：
        - 返回的字段名必须完全基于接口定义中的英文字段，不得包含中文或中文解释。
        - 仅返回存在依赖关系的字段，不需附加信息或解释。

        ##示例：
        正确示例：[nick,channel]
        错误示例：[名称,版本]

        """



        # 调用 chat 函数，生成响应
        response = chat(prompt)
        return response
    
    except FileNotFoundError as e:
        return f"Error: {e}"
    except Exception as e:
        return f"An unexpected error occurred: {e}"


@tool
def FindLog(input_string:str)->str:
    """
    ## 工具描述：从原始日志中筛选出与指定参数相关的关键日志记录。该函数根据所需的API接口集合和相关字段，从提供的原始日志中提取出符合条件的日志信息。

    ## 输入变量说明：
    传入变量为`input_string`，包含以下内容，使用空格分隔：
    1. 测试所需API接口信息的CSV文件路径（`api_des_path`），
    2. 原始日志文件的路径（`cleaned_path`），
    3. 可能与日志参数相关的字段名称列表（`possible_fields`），例如：`['a', 'n']`。

    示例输入格式："merged.csv cleaned.csv ['a','n']"

    :param api_des_path: 包含测试所需API接口信息的CSV文件路径。
    :param cleaned_path: 原始日志文件的路径，包含待处理的日志数据。
    :param possible_fields: 与日志参数相关的字段名称列表，用于筛选关键日志。

    :return: 返回一个字符串，告知所找到日志存放位置。
    """


    # 使用空格分割输入字符串
    # 去掉多余空格
    input_string = input_string.strip()

    # 使用空格分割字符串，限制为前两个分割
    parts = input_string.split(maxsplit=2)

    # 取前两个部分作为变量，最后一部分转换为列表
    api_des_path = parts[0]
    cleaned_path = parts[1]
    if not api_des_path.endswith('merged.csv') or not cleaned_path.endswith('cleaned.csv'):
        return "传入路径错误，需要使用以 'merged.csv' 和 'cleaned.csv' 结尾的路径。"
    # 使用 ast.literal_eval() 将字符串转为列表
    # 去掉列表字符串前后的空格
    list_string = parts[2].strip().replace('"', '')
    possible_fields = ast.literal_eval(list_string)
    print(possible_fields)
    df = find_and_extract_fields(api_des_path,cleaned_path, possible_fields)
    selected_logs = sort_and_select_logs(df, api_des_path)
    
    # 获取 api_des_path 的目录
    directory = os.path.dirname(api_des_path)

    # 在同一目录下创建 select_log.txt 并写入日志
    select_log_path = os.path.join(directory, "select_log.txt")
    with open(select_log_path, 'w', encoding='utf-8') as file:
        file.write(str(selected_logs))

    # 返回日志文件的路径
    return f"日志已存储在: {select_log_path}"



@tool
def RunQTACode(input_test_file: str) -> str:
    """
    ## 工具描述:执行指定的 QTA 测试用例文件，并返回测试结果。
    ##示例输入格式："/path/to/test_n.py"
    :param input_test_file: QTA接口测试用例文件的路径。
    :return: 测试结果的输出内容
    """
    input_test_file=input_test_file.strip('"').strip("'").strip().replace('"', '').replace("'", '').replace("/", ".")
    match = re.search(r'\.([^.]+)\.([^.]+)\.py$', input_test_file)
    if match:
        input_test_file = f"{match.group(1)}.{match.group(2)}"
    else:
        return "输入路径不正确未找到对应的 .py 文件"
   
    # 运行 QTA 并获取输出结果
    command = 'python '+'medtesttestproj/manage.py '+'runtest '+input_test_file
    try:
        # 通过 subprocess 运行命令并捕获输出，指定编码为 utf-8
        result = subprocess.run(command, capture_output=True, text=True, check=True, shell=True, encoding='utf-8', errors='replace')

        # 将标准输出和标准错误保存为字符串
        output = result.stdout  # 标准输出
        #error_output = result.stderr  # 标准错误
        print(output)
        return output  # 返回输出和错误输出作为字符串
    except subprocess.CalledProcessError as e:
        # 如果命令失败，捕获并返回错误信息
        return e.stdout  # 返回捕获到的输出和错误信息

@tool
def GenerateQTATestcase(input_string: str)->str:
    
    """
    ## 工具描述:根据输入的日志和文本生成 QTA 接口测试用例，并将结果保存到指定路径中。
    ## 若通过此工具生成的测试用例如果无法正确运行可能由于LLM出错导致，请重试几次！！
    ## 输入变量说明：
    传入变量为`input_string`，包含以下内容，使用空格分隔：
    1. 测试存放文本用例的文件路径(文件类型为.txt)（`testcase_path`），
    2. 生成的 QTA 测试用例代码保存路径(文件类型为.py)（`response_path`），
    3. 生成的 QTA 测试用例所需日志的保存路径(文件类型为.txt)（`log_path`），
    4. 生成的 QTA 测试用例测试用例对应调用接口集(文件类型为.csv)（`merge_pathh`），
    5. 存在依赖字段的列表（possible_fields），

    示例输入格式："/path/to/testcase /path/to/response /path/to/log /path/to/merge_path[possible_field1,possible_field2]"

    :param selected_logs: 包含用于生成测试用例的日志数据。
    :param my_text: 用于生成测试用例的文本用例。
    :param response_path: 生成的 QTA 测试用例代码保存路径。
    :param merge_path:生成测试用例所需接口集
    :param possible_fields:存在依赖的参数
    """
    #textcase_path: str, response_path: str,selected_logs: str
    match = re.match(r"(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\[.*?\])", input_string)
    if match:
        textcase_path = match.group(1).replace("'", "").replace('"', "")
        response_path = match.group(2).replace("'", "").replace('"', "")
        selected_logs_path = match.group(3).replace("'", "").replace('"', "")
        merge_path= match.group(4).replace("'", "").replace('"', "")
        possible_fields = match.group(5)
    else:
        return ValueError(f"无法从输入中提取路径，请检查输入是否正确")
    print(textcase_path)
    print(response_path)
    print(selected_logs_path)
    print(possible_fields)

    url_and_steps = get_url_and_steps(merge_path)
    print(url_and_steps)
    #读取文本用例
    if not os.path.exists(textcase_path):
    # 如果路径不存在，创建路径（包括父级目录）
        os.makedirs(os.path.dirname(textcase_path), exist_ok=True)
    with open(textcase_path, 'r', encoding='utf-8') as file:
        my_text = file.read()

    #读取日志集
    if not os.path.exists(selected_logs_path):
    # 如果路径不存在，创建路径（包括父级目录）
        os.makedirs(os.path.dirname(selected_logs_path), exist_ok=True)
    with open(selected_logs_path, 'r', encoding='utf-8') as file:
        logs = file.read()

    prompt = f"""
        ./Chinese
        ## 角色设定：
        你是一个具有十年以上经验的接口测试工程师，专注于接口自动化测试。你擅长评估测试用例的有效性，你知道测试用例运行通过并不意味着断言是高质量且准确的，特别是在调用关系和断言的准确性方面。

        ## 目标：  
        基于提供的日志、功能测试用例、设计接口测试用例意见与可能依赖的参数，生成完整的、可运行的 QTA 接口测试用例，用于 API 场景的自动化测试。生成的测试代码不仅要处理请求参数、响应验证和异常处理，还要特别关注接口操作执行后的结果验证，确保测试中明确验证修改后的数据是否符合预期。此外，若接口之间存在参数依赖，应在测试用例中实现参数的流转。

        ## 需求细分：  
        1. 日志解析：  
        - 从提供的日志中提取所有请求参数和响应内容，包括 URL、请求体、响应体等。  
        - 识别并解析接口间的参数依赖关系，明确参数如何从一个接口传递到另一个接口。  
        - 在测试用例中重现依赖关系，并在不同测试步骤中体现参数流转。

        2. 接口测试用例的代码结构：  
        - 代码结构应参考如下模板：  
            ```python
            import requests
            from testbase.testcase import TestCase

            class ExampleTest(TestCase):
                '''测试用例示例'''
                
                owner = "Mini_LLM"
                status = TestCase.EnumStatus.Ready
                priority = TestCase.EnumPriority.Normal
                timeout = 5
                
                def get_headers(self):
                    '''获取公共请求头'''
                    return {{
                        "th-session-id": requests.get('http://ubein.cn:82/session_id').json()['session_id'],
                        "Content-Type": "application/json"
                    }}

                def test_example(self):
                    '''用例步骤'''
                    self.start_step("测试步骤描述")
                    url = "https://example.com/api/endpoint"
                    body = {{
                        "request": {{
                            "param1": "value1"
                        }},
                        "context": {{
                            "param1": "value1"
                        }}
                    }}
                    response = requests.post(url, json=body, headers=self.get_headers())
                    response.raise_for_status()
                    response_json = response.json()

                    # 断言检查
                    self.assert_("检查返回码是否为0", response_json['code'] == 0)
                    self.assert_("检查返回消息是否为'success'", response_json['msg'] == 'success')

                def run_test(self):
                    '''执行测试步骤'''
                    self.test_example()
                    self.assert_("用例步骤名称", "断言")
            
            if __name__ == '__main__':
                ExampleTest().debug_run()
            ```

        3. 特别注意事项：  
        - 结果验证：测试用例不仅要执行接口的操作，还必须在操作后验证结果，确保修改后的数据是否符合预期。在每一步的测试中，执行操作后都应通过断言来验证结果与预期是否一致。  
        - 响应验证：响应的结构和格式必须与 API 的返回结构一致。检查响应码、关键消息字段、关键参数值等。基于日志内容进行正确，且详细的断言验证。确保测试中验证修改后的数据是否符合预期。此外，若接口之间存在参数依赖，应在测试用例中实现参数的流转  
        - 功能覆盖：测试用例必须覆盖 API 的核心功能，确保测试步骤能真实模拟业务场景，并且结果验证环节不可省略。  
        - 步骤分离：不同的测试步骤应使用独立的方法实现！！！！！！！并且这些步骤应当体现参数依赖的流转逻辑。例如，某些参数可能在一个接口响应中获取，后续接口需要使用这些参数作为请求数据。  
        - 异常处理：测试用例中应对 API 请求失败或响应异常情况进行处理，确保测试能够在异常情况下给出清晰的错误提示。
        - 接口调用：参数以及接口调用时步骤不能存在假设调用！！！！！所调用参数，接口都应现实存在！！！！


        4. 输出要求：  
        - 生成的 QTA 接口测试用例应符合上述规则和模板（必须包含规定'''获取公共请求头'''的方法）。  
        - 验证环节：在测试操作执行后，若场景中存在修改或者写入务必验证修改后的数据是否已经成功更新并与预期相符，所有关键业务流程的执行结果都应通过断言进行验证。  
        - 代码结构清晰，步骤分离明确。  
        - 用例可直接运行，且能处理接口依赖并验证预期结果。
        

        ##用于生成QTA接口测试用例的日志、设计接口测试用例意见以及文本用例步骤如下
            - 可能存在依赖的字段
            {possible_fields}
            - 用例步骤：
            {my_text}
            - 用例步骤及其对应可能调用接口：
            {url_and_steps}
            - 日志：
            {logs}     
"""
    response=chat(prompt)
    QTA_code=extract_llm_test(response)
    
    dir_name = os.path.dirname(response_path)
    if dir_name:  # 防止路径为空或为当前目录
        os.makedirs(dir_name, exist_ok=True)

    with open(response_path, 'w', encoding='utf-8') as file:
        file.write(QTA_code)

    return f"""接口测试用例已保存到{response_path}中

    """

@tool
def QTALLMFixer(input_string: str) -> str:
    """
    ## 工具描述:输入文本用例路径和 QTA 接口测试用例路径后，该工具将调用agent针对运行结果中的断言错误尝试进行修复。
    ## 请注意：在使用该工具后应当对修改后的测试用例进行运行校验

    ## 输入变量说明：
    传入变量为`input_string`，包含以下内容，使用空格分隔：
    1. 测试存放文本用例的文件路径(文件类型为.txt)（`testcase_path`），
    2. 生成的 QTA 测试用例代码保存路径(文件类型为.py)（`QTA_code_path`），
    3. 生成的 QTA 测试用例所需日志的保存路径(文件类型为.txt)（`log_path`），
    4. 存在依赖字段的列表（possible_fields），

    示例输入格式："/testcase_path /QTA_code_path /log_path [possible_field1,possible_field2]"
    """
    # 创建工具列表
    tools = [RunQTACode,ImproveAssertionQuality,FixResponseError,CheckTestCaseCompliance]

    # 创建提示模板
    prompt_template = PromptTemplate.from_template(template)

    match = re.match(r"(\S+)\s+(\S+)\s+(\S+)\s+(\[.*?\])", input_string)
    if match:
        testcase_path = match.group(1).replace("'", "").replace('"', "")
        QTA_code_path = match.group(2).replace("'", "").replace('"', "")
        log_path = match.group(3).replace("'", "").replace('"', "")
        possible_fields = match.group(4)
    else:
        return ValueError("无法从输入中提取路径，请检查输入是否正确")


    AddLogStatements(QTA_code_path)

    prompt = f"""
    ### 修复QTA测试用例

    以下是 QTA 测试用例代码，其中存在一些断言错误。请使用相关工具进行修复，确保测试用例符合文本用例的预期。

    #### 输入的文件路径:
    请严格记得以下文件的路径！！！！
    - 文本测试用例路径:         {testcase_path}
    - QTA测试用例代码路径:      {QTA_code_path}
    - 用于生成测试用例的日志路径:{log_path}

    #### 可能存在依赖的字段:
    {possible_fields}

    ### 请使用挑选适合工具进行修复,直至你觉得存放在QTA测试用例代码路径的代码符合预期即可结束该流程
    ### 请注意，如果调用三次修复工具后仍未能修复测试用例，则直接结束流程返回无法修复测试用例建议重新生成。
    """

    # 使用 React Agent 生成修复后的代码
    memory = ConversationBufferMemory()
    agent = create_react_agent(llm_model, tools, prompt_template)
    agent_executor = AgentExecutor(
        agent=agent,
        tools=tools,
        memory=memory,
        verbose=True,
        handle_parsing_errors=True,
        output_key="output",
        max_iterations=6
    )
    
    ans = agent_executor.invoke(user_input_dict)["output"]
    if ans!="Agent stopped due to iteration limit or time limit.":
        return ans
    return "LLM修复器达到最大迭代次数,测试用例不确定是否已被完全修复,请通过运行验证修复验证结果"

    



@tool
def CheckTestCaseCompliance(input_string: str) -> str:
    """
    ## 工具描述: 该工具用于判断接口测试用例是否符合文本用例场景要求。当其认为用例步骤与QTA测试用例严重不符,请结束修复流程，无修复意义时请直接结束流程。
                 建议在正式开始修复接口测试用例之间使用该工具判断该用例是否有修复必要。
    ## 输入变量说明：
    传入变量为`input_string`，包含以下内容，使用空格分隔：
    1. 测试存放文本用例的文件路径(文件类型为.txt)（`testcase_path`），
    2. QTA 测试用例代码保存路径(文件类型为.py)（`qta_code_path`）。

    示例输入格式："/path/to/testcase.txt /path/to/qta_code.py"
    """
    match = re.match(r"(\S+)\s+(\S+)", input_string)
    if match:
        testcase_path = match.group(1).replace("'", "").replace('"', "")
        qta_code_path = match.group(2).replace("'", "").replace('"', "")
    else:
        return ValueError("无法从输入中提取路径，请检查输入是否正确")

    # 读取文本用例和 QTA 测试用例代码
    if not os.path.exists(testcase_path):
        return f"无法找到文本用例路径 {testcase_path}"
    if not os.path.exists(qta_code_path):
        return f"无法找到 QTA 测试用例路径 {qta_code_path}"

    with open(testcase_path, 'r', encoding='utf-8') as file:
        testcase_content = file.read()

    with open(qta_code_path, 'r', encoding='utf-8') as file:
        qta_code_content = file.read()

    prompt = f"""
    ### 评估接口测试用例与其对应的文本用例逻辑是否匹配


    请比对以下文本用例描述和 QTA 测试用例代码，专注于接口测试用例中调用的接口步骤是否与文本用例的描述一致。由于文本用例可能包含非API调用的步骤，本次评估只针对涉及到的API调用及其断言内容。
    
    #### 文本用例:
    {testcase_content}

    #### QTA 测试用例代码:
    {qta_code_content}

    ### 注意:
    - 只评估接口测试用例（API步骤）的相关程度，忽略文本用例中隐藏的其他交互方式，不评估用户页面交互。
    - 某些步骤属于非API调用的步骤，QTA接口测试用例中没体现到非API调用步骤是正确的
    - 只评估发送的请求与调用的接口是否是改步骤会调用到的接口即可。无需过多关注断言正确性。
    - 请直接给出用例契合程度的评估结果包括原因，无需修改测试用例。

     ### 任务说明:
    - 评估接口调用和断言内容是否与文本用例步骤相匹配。
    - 如接口调用与用例步骤存在严重不符，包括某些步骤存在API调用但是该却没有在测试用例中调用该API。反馈为：“用例步骤与QTA测试用例不符，请结束修复流程，无修复意义。
    - 如接口调用与用例步骤相符，反馈为：“用例步骤与QTA测试用例相符，有进行修复的价值。”并简要说明原因
        
"""

    response = chat(prompt)
    return response


@tool
def ImproveAssertionQuality(input_string: str) -> str:
    """
    ## 工具描述: 该工具用于根据运行 QTA 的打印响应内容，结合文本用例，提高 QTA 接口测试用例的断言质量以及断言准确性。
    ## 请注意：在使用该工具之后应当对修改后的测试用例进行运行校验
    ## 输入变量说明：
    传入变量为`input_string`，包含以下内容，使用空格分隔：
    1. QTA 测试用例代码保存路径(文件类型为.py)（`qta_code_path`），
    2. 测试存放文本用例的文件路径(文件类型为.txt)（`testcase_path`），
    3. 存在依赖字段的列表（possible_fields）。

    示例输入格式："/qta_code_path  /testcase_path [possible_field1,possible_field2]"
    """
    match = re.match(r"(\S+)\s+(\S+)\s+(\[.*?\])", input_string)
    
    if match:
        qta_code_path = match.group(1).replace("'", "").replace('"', "")
        testcase_path = match.group(2).replace("'", "").replace('"', "")
        possible_fields = match.group(3)
    else:
        return ValueError("无法从输入中提取路径，请检查输入是否正确")

    # 读取 QTA 测试用例代码、日志内容和文本用例
    if not os.path.exists(qta_code_path):
        return f"无法找到 QTA 测试用例路径 {qta_code_path}"
    
    if not os.path.exists(testcase_path):
        return f"无法找到文本用例路径 {testcase_path}"

    with open(qta_code_path, 'r', encoding='utf-8') as file:
        qta_code_content = file.read()

    with open(testcase_path, 'r', encoding='utf-8') as file:
        testcase_content = file.read()
    
    log_content=RunQTACode(qta_code_path)
    prompt = f"""
        ./Chinese
        ## 角色设定：
        你是一名拥有十年以上经验的接口自动化测试工程师，擅长通过分析测试日志来优化测试用例中的断言。

        ## 任务说明：
        -根据接口测试运行结果，首先系统分析断言发生错误的原因
        -然后改进测试用例中的断言，使其能在不大幅修改QTA测试框架代码结构的前提下正确执行。通过分析代码运行后打印出来的回包日志，提升断言的准确性和覆盖率。
        -确保所有参数和接口调用真实存在，不能假设或编造数据。
        -确保测试用例中有传入生成测试用例所需的关键参数以及关联参数

        - 如果测试用例中存在参数依赖，应该确保不同接口之前的参数依赖流转是符合文本用例逻辑的。
        - 不允许臆造接口参数或回包信息进行断言，所有调用都必须基于真实存在的接口和数据。
        - 如果修改后的测试用例包含日志打印代码，需将日志输出限制在1000字符内，如：self.log_info(f"Response Body: {{response.text[:1000]}}")。
        -以下是get_headers方法，这个方法必须原封不动在代码中出现
        def get_headers(self):
                        '''获取公共请求头'''
                        return {{
                            "th-session-id": requests.get('http://ubein.cn:82/session_id').json()['session_id'],
                            "Content-Type": "application/json"
                        }}
        ## 输出说明：
        应该输出修改后的完整代码

        ## 可能依赖的字段：
        {possible_fields}

        ## 文本用例：
        {testcase_content}

        ## QTA 测试用例代码：
        {qta_code_content}

        ## QTA 测试用例运行结果：
        {log_content}
        """


    response = chat(prompt)
    QTA_code=extract_llm_test(response)
    # 保存更新后的代码
    with open(qta_code_path, 'w', encoding='utf-8') as file:
        file.write(QTA_code)

    return f"已根据运行结果尝试提高断言质量，更新后的 QTA 测试用例已保存到: {qta_code_path} 中。请运行测试观察其运行是否符合预期"


@tool
def FixResponseError(input_string: str)->str:
    """
    ## 工具描述:该工具用于根据接口返回的400等格式错误响应，结合文本用例和接口测试用例，修复格式错误并确保请求成功。
    ## 请注意：在使用该工具后应当对修改后的测试用例进行运行校验

    ## 输入变量说明：
    传入变量为`input_string`，包含以下内容，使用空格分隔：
    1. 测试存放文本用例的文件路径(文件类型为.txt)（`testcase_path`），
    2. 生成的 QTA 测试用例代码保存路径(文件类型为.py)（`QTA_code_path`），
    3. 生成的 QTA 测试用例所需日志的保存路径(文件类型为.txt)（`select_log_path`），

    示例输入格式："/testcase_path /QTA_code_path /select_log_path "
    """
    """
    :param testcase_path: 文本用例。
    :param QTA_code_path: QTA 测试用例代码路径。
    :param selected_logs: 包含用于生成测试用例的日志数据。
    """

    match = re.match(r"(\S+)\s+(\S+)\s+(\S+)", input_string)
    if match:
        testcase_path = match.group(1).replace("'", "").replace('"', "")
        QTA_code_path = match.group(2).replace("'", "").replace('"', "")
        log_path = match.group(3).replace("'", "").replace('"', "")

    else:
        return ValueError(f"无法从输入中提取路径，请检查输入是否正确")
    print(testcase_path)
    print(QTA_code_path)
    print(log_path)

    # 读取文本用例
    if not os.path.exists(testcase_path):
        return f"Test case file not found: {testcase_path}"
    try:
        with open(testcase_path, 'r', encoding='utf-8') as file:
            my_text = file.read()
    except IOError as e:
        return f"Error reading test case file: {str(e)}"
    # 读取日志文件
    if not os.path.exists(log_path):
        return f"Log file not found: {log_path}"
    try:
        with open(log_path, 'r', encoding='utf-8') as file:
            selected_logs = file.read()
    except IOError as e:
        return f"Error reading log file: {str(e)}"
    # 读取QTA代码文件
    if not os.path.exists(QTA_code_path):
        return f"QTA code file not found: {QTA_code_path}"
    try:
        with open(QTA_code_path, 'r', encoding='utf-8') as file:
            code = file.read()
    except IOError as e:
        return f"Error reading QTA code file: {str(e)}"

    code_res=run_QTA_and_return_result(QTA_code_path)

    prompt = f"""
    ./Chinese
    ## 角色设定：
        你是一个具有十年以上经验的接口测试工程师，擅长处理接口请求中因发送请求格式错误产生的报错。你的任务是根据接口返回的错误（如400响应），结合文本用例和接口测试用例，修复请求中的格式错误，确保请求成功。

        ## 任务说明：
        以下是 QTA 接口测试用例代码和运行结果，分析返回的错误信息，特别是400等格式错误，修复测试用例代码中的问题，确保请求成功。

        ## 特别注意事项：
        - 确保请求的数据格式、字段名称和请求体结构符合接口的规范。
        - 修改导致响应失败部分的代码
        -如果返回状态码400可能是因为没有正确设置header，以下是get_headers方法，这个方法必须原封不动在代码中出现
        def get_headers(self):
                        '''获取公共请求头'''
                        return {{
                            "th-session-id": requests.get('http://ubein.cn:82/session_id').json()['session_id'],
                            "Content-Type": "application/json"
                        }}
        - 每次修改后，应确保修改后的代码能够正常运行并且接口返回成功。
        - 必须使用代码结构模板的get_headers(self)方法获取公共请求头

        ##改进后的接口测试用例的代码结构：  
            - 代码结构应参考如下模板：  
                ```python
                import requests
                from testbase.testcase import TestCase

                class ExampleTest(TestCase):
                    '''测试用例示例'''
                    
                    owner = "Mini_LLM"
                    status = TestCase.EnumStatus.Ready
                    priority = TestCase.EnumPriority.Normal
                    timeout = 5
                    
                    def get_headers(self):
                        '''获取公共请求头'''
                        return {{
                            "th-session-id": requests.get('http://ubein.cn:82/session_id').json()['session_id'],
                            "Content-Type": "application/json"
                        }}

                    def test_example(self):
                        '''用例步骤一'''
                        self.start_step("测试步骤描述")
                        url = "https://example.com/api/endpoint"
                        body = {{
                            "request": {{
                                "param1": "value1"
                            }},
                            "context": {{
                                "param1": "value1"
                            }}
                        }}
                        response = requests.post(url, json=body, headers=self.get_headers())
                        self.log_info(f"Response Body: {{response.text[:1000]}}")#打印返回结果便于出错调试修复
                        response.raise_for_status()
                        response_json = response.json()

                        # 断言检查
                        self.assert_("检查返回码是否为0", response_json['code'] == 0)
                        self.assert_("检查返回消息是否为'success'", response_json['msg'] == 'success')

                    def run_test(self):
                        '''执行测试步骤'''
                        self.test_example()
                        self.assert_("用例步骤名称", "断言")
                
                if __name__ == '__main__':
                    ExampleTest().debug_run()
                ```

        ## 输出要求：
        - 修改后生成的 QTA 接口测试用例应符合上述规则和模板。
        - 应输出完整全部代码
        - 代码结构清晰，步骤分离明确。
        - 用例可直接运行，且能处理接口依赖并验证预期结果。

        ##文本用例**：
        {my_text}

        ##QTA 测试用例代码**：
        {code}

        ##QTA 测试用例代码运行结果**：
        {code_res}

        ##生成测试用例所用到的日志
        {selected_logs}

        """

    response=chat(prompt)
    QTA_code=extract_llm_test(response)
    
    dir_name = os.path.dirname(QTA_code_path)
    if dir_name:  # 防止路径为空或为当前目录
        os.makedirs(dir_name, exist_ok=True)

    with open(QTA_code_path, 'w', encoding='utf-8') as file:
        file.write(QTA_code)

    return f"""修改后的接口测试用例已保存到{QTA_code_path}中
    """


if __name__ == '__main__':
    # 创建工具列表
    tools = [RunQTACode,FindPossibleFieldsByLLM,FindLog,GenerateQTATestcase,QTALLMFixer]
    #tool_names = ", ".join([tool.name for tool in tools])
    # 创建提示模板
    prompt_template = PromptTemplate.from_template(template)
    for i in range(1,4):
        data_root="datasets/"
        data_URL = data_root + str(i)
        log_path = f'{data_URL}/cleaned.csv'
        merge_path = f'{data_URL}/merged.csv'
        testcase_path=f"{data_URL}/testcase.txt"
        test_code_path = f"medtesttestproj/MedTesttest/test_{i}.py"

        with open(testcase_path, 'r', encoding='utf-8') as file:
                testcase = file.read()

        user_input_dict = {
            "input": f'''
                    根据以下文本用例，接口集，以及原始日志生成QTA测试用例.
                    
                    ##文本用例：
                    {testcase}
                    ##文件存放路径
                    # 请牢记以下文件存放路径！！避免产生幻觉！
                    原始日志集存放路径为:"{log_path}"
                    接口集csv文件存放路径为:"{merge_path}"
                    请牢记接口测试用例文件存放路径！！接口测试用例文件存放路径为，这可以给你暂时存放已生成的测试用例:"{test_code_path}"
                    文本用例存放路径为:"{testcase_path}"

                    ##注意
                    # 原始日志集体积过大，你应该首先使用各种tool提取原始日志中的有效信息找到有效小体量的日志再去生成测试用例
                    # 当调用工具GenerateQTATestcase时,对应生成的QTA接口测试用例就会被保存在接口测试用例文件存放路径之中,
                    # 你的tool的性质可分成两类，一类是帮助你获取生成测试用例所需要的信息，一类是让你验证使用工具后得到的信息是否准确。
                    # 如果发现生成的测试用例存在运行错误或者断言错误需要打回重新生成
                    ！

                    ## 特别注意！！！
                    在生成测试用例后，请使用相应的工具或者利用你的专业知识对生成的测试用例进行检查，确保以下几点：
                    1. 参数准确性：检查关联参数的准确性。
                    2. 运行验证：确认生成的测试用例能够成功运行,最后交给我的测试用例必须可以被正确运行，且结果正确。
                    3. 断言准确性：获取代码具体内容并仔细检查测试代码中的断言，确保其准确且能够反映依赖参数在代码中的流转以及断言高度准确，符合文本用例场景要求。
                    4.If you find that the QTA generated by the tools is incorrect, you cannot modify it yourself and need to rely on the tools to regenerate it.
                    测试用例运行正确并不代表断言一定准确，务必进行全面的验证
                    
                    ##Final Answer格式：
                    Final Answer: The final answer to the original input question, verified by the QTA result, is as follows:......

                    
                    '''
        }
        memory = ConversationBufferMemory()
        # 创建Agent 
        agent = create_react_agent(llm_model, tools, prompt_template)
        ##创建 AgentExecutor
        agent_executor = AgentExecutor(
            agent=agent,
            tools=tools,
            memory=memory,
            verbose=True,
            handle_parsing_errors=True,
            output_key="output" ,
            max_iterations=10 
        )
        agent_executor.invoke(user_input_dict)


